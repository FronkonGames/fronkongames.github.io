---
author: Martin Bustos
title: Glitches
showTitle: false
date: 4
description: Add digital and analog glitches to increase the realism of your games
tags: ["unity", "store", "glitch", "hack"]
metadata: none
showImage: true
thumbnail:
  url: img/glitches.jpg
---

'**[Glitches](https://assetstore.unity.com/packages/vfx/shaders/fullscreen-camera-effects/glitches-bundle-295977?aid=1101l9zFC&utm_source=aff)**' is a collection of cinematic distortion and glitch effects to enhance visual storytelling in games and interactive experiences. Contains the following assets:

* [Corrupt Memory](#corruptmemory), a cyber attack? no, it's just corrupted memory.
* [Interferences](#interferences), something is interfering with the signal...
* [VHS](#vhs), the beauty of analog.
* [Distortions](#distortions), distortions effects to increase the awesomeness of your games.
* [Cheap Camera](#cheap-camera), emulates the defects of cheap cameras with poor quality digital sensors.
* [Bad GPU](#bad-gpu), simulates the effects of a broken GPU.
* [Artifacts](#artifacts), generated by a bad video reception or excessive compression.
* [Hacked](#hacked), smile... you r being hacked :)
* [Broken LCD](#broken-lcd), simulated.
* [Color Blindness](#colorblindness), simulates the most common vision defects.

{{< alert color="light" >}}
You can obtain each effect separately, but if you want multiple effects, you might be interested in **'[GLITCHES BUNDLE](https://assetstore.unity.com/packages/vfx/shaders/fullscreen-camera-effects/glitches-bundle-295977?aid=1101l9zFC&utm_source=aff)'** where you can find them all at a special price!
{{< /alert >}}

## Requirements

All '**Glitches**' effects are developed for '[Universal Render Pipeline](https://docs.unity3d.com/6000.0/Documentation/Manual/urp/urp-introduction.html)' (or URP), which means they will **not work** with Built-In, or HDRP.

#### Unity 6 or Higher

All effects are compatible with **Unity 6**, and use the new [Render Graph](https://docs.unity3d.com/6000.0/Documentation/Manual/urp/render-graph-introduction.html). You will need to have URP version *17.0.2* or higher installed. In the [official documentation](https://docs.unity3d.com/6000.0/Documentation/Manual/urp/InstallURPIntoAProject.html) you can find the steps to install it correctly.

Make sure that the '_Compatibility Mode_' is **disabled** (_Project Settings > Graphics > Render Graph_).

{{< image src="compatibility_mode.jpg" wrapper="col-6 mx-auto">}}

## Installation

#### Step 1: Add Renderer Feature

The effects must be registered in your project's [URP configuration](https://docs.unity3d.com/6000.0/Documentation/Manual/urp/introduction-landing.html):

1. Locate your **Universal Renderer Data** asset.
2. Click **Add Renderer Feature** and select the desired distortion from **Fronkon Games > Glitches**.

Once installed, you have to add the effect you want to use from '**Glitches**' as a '[Render Feature](https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@12.1/manual/urp-renderer-feature.html)'. This [official tutorial](https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@12.1/manual/urp-renderer-feature-how-to-add.html) tells how to do it.

Remember that the camera you are using must have the '**Post Processing**' option enabled.

{{< image src="editor_camera.jpg" wrapper="col-8 mx-auto">}}

{{< alert color="info" >}}
'_Quality_' levels (_Project Settings > Quality_) can have their own active '_Render Pipeline Asset_'.

If so, whatever you assign in '_Scriptable Render Pipeline Settings_' in '_Graphics_' will be ignored.

**Remember to add the effect to the quality levels you want to use.**
{{< /alert >}}

#### Step 2: Configure The Volume

To apply the effects to your scene:

1. Create a **Volume** component (Global or Local) or select one that has already been created.
2. In the Volume component, create or assign a **Volume Profile**.
3. Click **Add Override** and select the desired distortion from **Fronkon Games > Glitches**.
4. Enable the '**Intensity**' parameter (and any others you wish to modify).

{{< alert color="info" >}}
Remember that for a parameter to take effect, you must activate it. Click on '**ALL**' to activate them all.
{{< /alert >}}

#### VR

To increase compatibility with VR devices, I recommend that you select '**Stereo Rendering Mode**' in '**Multi Pass**' mode:

{{< image src="vr.jpg" wrapper="col-8 mx-auto">}}

#

---
## üíæ Corrupt Memory {#corruptmemory}
{{< asset-header youtube="F4ubH6fGgcA" store="https://assetstore.unity.com/packages/vfx/shaders/fullscreen-camera-effects/glitches-corrupt-memory-274730" demo="https://fronkongames.github.io/demos-glitches/corruptmemory/" warn="assets used in video and demo are not included">}}

**Corrupt Memory** simulates the visual degradation that occurs during video memory corruption or cyberattack scenarios. By generating patterns of overlapping rectangles with randomized properties, this effect creates zones where pixelation, chromatic aberration, and image displacement are selectively applied, producing realistic digital artifacts that range from subtle data loss to catastrophic hardware failure visualizations.

#### Requisites

To ensure optimal performance and compatibility, your project must meet the following requirements:

*   **Unity:** 6000.0.58f1 or higher.
*   **Universal RP:** 17.0.3 or higher.

#### Instalation Guide

##### Step 1: Add Renderer Feature

The effect must be registered in your project's URP configuration:

1. Locate your **Universal Renderer Data** asset.
2. Click **Add Renderer Feature** and select **Fronkon Games > Glitches > Corrupt Memory**.

##### Step 2: Configure the Volume

To apply the effect to your scene:

1. Create a **Volume** component (Global or Local).
2. In the Volume component, create or assign a **Volume Profile**.
3. Click **Add Override** and select **Fronkon Games > Glitches > Corrupt Memory**.
4. Enable the '**Intensity**' parameter (and any others you wish to modify).

#### Three-Tier Effect System

The generated corruption pattern serves as a mask for three distinct effect layers, each activated independently based on threshold comparisons against the hash values.

{{< table >}}
| **Effect Layer** | **Activation Threshold** | **Visual Impact** | **Primary Parameters** |
|---|---|---|---|
| **Pixelation** | Corruption Z > Pixelation Threshold | Reduces effective resolution in corruption zones | Pixelation intensity [0-1], Threshold [0-1] |
| **Aberration**	 | Corruption.rgb > Aberration Threshold | Separates RGB channels at different offsets | Aberration XYZ [0-25], Threshold [0-1] |
| **Offset** | Corruption Z > Offset Threshold | Shifts texture coordinates radially | Offset [0-1], Scale [0-1], Threshold [0-1] |
{{< /table >}}

{{< alert type="info" >}}
The threshold parameters act as density filters. High threshold values (0.9+) limit effects to the most intense corruption zones, while low values (0.1-0.3) spread artifacts across larger screen areas.
{{< /alert >}}

##### Pixelation

Pixelation reduces sampling resolution by quantizing UV coordinates. The shader calculates a target pixel count between 256 and 8 based on the pixelation parameter, then uses floor division to snap coordinates to grid positions. This creates blocky artifacts visible only in zones where the corruption pattern exceeds the threshold, simulating GPU texture memory degradation.

##### Chromatic Aberration Application

Color channel separation occurs independently per RGB component, each sampling from different UV offsets. The offset magnitude depends on the corresponding channel's hash value exceeding the aberration threshold. This asymmetric channel separation creates rainbow-like fringes characteristic of display connector degradation or GPU memory errors.

##### Image Displacement Mechanism

Spatial displacement applies radial offset to UV coordinates, creating tearing effects. The offset direction derives from trigonometric functions of the hash values, while magnitude scales with the offset parameter and temporal fading. The sine-wave fade creates pulsating displacement intensity, while screen-parameter normalization ensures consistent artifact size across resolutions.

#### Parameter Configuration

{{< image src="corrupt_memory_0.jpg" wrapper="col-10 mx-auto">}}

With '**Intensity**' you can control the overall strength of the effect [0.0 - 1.0]. If it is 0, the effect will not be active.

{{< table >}}
| **Parameter** | **Range** | **Default** | **Effect** |
|---|---|---|---|
| **Complexity** | 0-15 | 5.0 | Number of recursive iterations. Higher values create more intricate patterns at increased GPU cost |
| **Density** | 0-1 | 0.2 | Probability of corruption zone activation. Lower values create sparse, dramatic artifacts |
| **Speed** | 0-25 | 10.0 | Temporal evolution rate. Controls how quickly patterns morph and migrate |
| **Scrolling** | Vector2 | (0, 0) | Manual pattern displacement. Enables directional movement of corruption zones |
| **Zoom** | Vector2 | (11, 7) | Spatial scaling of pattern generation. Larger values produce smaller, more numerous artifacts |
{{< /table >}}

{{< alert type="info" >}}
Complexity beyond 10 iterations rarely yields visible improvements but significantly impacts performance. For mobile platforms, stay within the 3-7 range.
{{< /alert >}}

{{< table >}}
| **Parameter** | **Sub-Parameter** | **Range** | **Default** | **Purpose** |
|---|---|---|---|---|
| **Pixelation** | Intensity | 0-1 | 0.25 | Amount of resolution reduction (256‚Üí8 pixels) |
|  | Threshold | 0-1 | 0.9 | Minimum corruption intensity to trigger pixelation |
| **Aberration** | RGB Intensity | 0-25 | (10,10,10) | Channel offset magnitude in texels |
|  | Threshold | 0-1 | 0.9 | Per-channel activation requirement |
| **Offset** | Intensity | 0-1 | 0.25 | Maximum UV offset amount |
|  | Scale | 0-1 | 0.5 | Screen-space normalization factor |
|  | Threshold | 0-1 | 0.9 | Minimum corruption for displacement |
{{< /table >}}

##### Color Grading

Standard color correction parameters apply to the final output.

{{< table >}}
| **Parameter** | **Range** | **Effect** | **Default** |
|---|---|---|---|
| Brightness | -1.0 to 1.0 | Additive luminance offset | 0.0 |
| Contrast | 0.0 to 10.0 | Mid-tone contrast expansion | 1.0 |
| Gamma | 0.1 to 10.0 | Nonlinear tonal mapping (inverted) | 1.0 |
| Hue | 0.0 to 1.0 | Color wheel rotation | 0.0 |
| Saturation | 0.0 to 2.0 | Color intensity relative to luminance | 1.0
{{< /table >}}

These operations follow standard image processing order: contrast expansion ‚Üí hue rotation ‚Üí gamma correction ‚Üí saturation adjustment.

##### Runtime Control

Effect control follows the standard Unity Volume API pattern. Access parameters through the Volume component after retrieving it from the active profile:

```csharp
using FronkonGames.Glitches.CorruptMemory;
using UnityEngine.Rendering;

[SerializeField] 
private VolumeProfile volumeProfile;

private CorruptMemoryVolume corruptMemory;
 
private void Awake()
{
    // Retrieve the volume component
    volumeProfile.TryGet(out corruptMemory);
}
 
private void ApplyCorruptionEffect(float severity)
{
    // Scale pattern intensity with event severity
    corruptMemory.intensity.value = severity;
    
    // Increase density for more extensive damage
    corruptMemory.density.value = Mathf.Lerp(0.1f, 0.8f, severity);
    
    // Accelerate pattern evolution during critical events
    corruptMemory.speed.value = Mathf.Lerp(5.0f, 25.0f, severity);
    
    // Enable all three effect layers
    corruptMemory.pixelation.value = 0.5f * severity;
    corruptMemory.aberration.value = Vector3.one * (15.0f * severity);
    corruptMemory.offset.value = 0.6f * severity;
    
    // Lower thresholds for broader effect application
    corruptMemory.pixelationThreshold.value = 1.0f - (0.3f * severity);
    corruptMemory.aberrationThreshold.value = 1.0f - (0.4f * severity);
    corruptMemory.offsetThreshold.value = 1.0f - (0.2f * severity);
}
```

The effect includes built-in debugging capabilities through the DEBUG_VIEW shader keyword. When enabled via the Debug View parameter, the shader renders the raw corruption pattern luminance instead of applying the three effect layers. This visualization reveals:

* Hash distribution across screen space
* Pattern complexity and iteration boundaries
* Density threshold effectiveness
* Temporal evolution characteristics

Use this mode when tuning pattern parameters to ensure artifact distribution matches intended visual design before enabling the full effect composition.

```csharp
corruptMemory.debugView.value = true;  // View hash-based pattern only
corruptMemory.debugView.value = false; // Apply full effect composition
```

##### Performance Considerations

The algorithmic complexity scales linearly with the complexity parameter. Each iteration incurs hash calculation, conditional branching, and coordinate transformation operations. On mobile hardware (Adreno 640+):

{{< table >}}
| **Complexity Setting** | **Estimated GPU Cost** | **Recommended Use Case** |
|---|---|---|
|1-3 | < 0.5ms | Mobile, heavy scenes |
|4-7 | 0.5-1.5ms | Desktop, balanced scenes |
|8-15 | 1.5-4ms | Cinematic, dedicated post-processing |
{{< /table >}}

Pixelation and chromatic aberration effects require additional texture samples. Minimize these costs by keeping thresholds high (0.85+) when effect intensity is low.

---
## üì° Interferences {#interferences}
{{< asset-header youtube="lYrj9jj3U8Y" store="https://assetstore.unity.com/packages/vfx/shaders/fullscreen-camera-effects/glitches-interferences-281861" demo="https://fronkongames.github.io/demos-glitches/interferences/" warn="assets used in video and demo are not included">}}

**Interferences** replicates the visual artifacts of signal degradation, electronic interference, and horizontal scanline noise. Ideal for "lo-fi" aesthetics, malfunctioning monitors, or digital transmission errors.

Once installed, when you select your '_Volume_', you will see something like this:

{{< image src="interferences_0.jpg" wrapper="col-10 mx-auto">}}

With '**Intensity**' you can control the overall strength of the effect [0.0 - 1.0]. If it is 0, the effect will not be active.

These parameters control the core signal degradation logic. Use '**Blend**' to define the mathematical operation used to mix interference layers, and adjust '**Offset**' to create chromatic aberration by displacing the color channels in the affected zones.

The horizontal image "tearing" is controlled through several distortion parameters: '**Distortion**' sets the maximum displacement, while '**Distortion Speed**' and '**Distortion Density**' define the evolution and vertical scale of the patterns.

You can further refine these with '**Distortion Amplitude**' and '**Distortion Frequency**' for more complex wave-like behaviors.

Finally, the horizontal scanline overlay can be customized using '**Scanlines**' visibility, '**Scanlines Density**' for spacing, and '**Scanlines Opacity**' for the darkening strength.

---
## üìº VHS {#vhs}
{{< asset-header youtube="f3W4_dPwZK0" store="https://assetstore.unity.com/packages/vfx/shaders/fullscreen-camera-effects/glitches-vhs-282181" demo="https://fronkongames.github.io/demos-glitches/vhs/" warn="assets used in video and demo are not included">}}

**VHS** is a post-processing effect designed to recreate the distinct look and artifacts of analog video tapes. It captures the essence of 80s and 90s home video, featuring magnetic tape noise, tracking errors, and color instability.

Once installed, when you select your '_Volume_', you will see something like this:

{{< image src="vhs_0.jpg" wrapper="col-10 mx-auto">}}

With '**Intensity**' you can control the overall strength of the effect [0.0 - 1.0]. If it is 0, the effect will not be active.

These parameters replicate the artifacts of magnetic tape playback. You can control the appearance of static with '**Noise**', its '**Noise Speed**', and '**Noise Size**'.

The color of this noise can be customized with '**Noise Color**' and its integration via '**Noise Blend**'.

Playback tracking errors, such as those seen during a pause, are simulated using the '**Pause**' parameter.

You can adjust the intensity of the interference band with '**Pause Band**', the amount of jitter with '**Pause Noise**', and the color/integration with '**Pause Color**' and '**Pause Blend**'.

---
## üåÄ Distortions {#distortions}
{{< asset-header youtube="ydWFcmFnSaU" store="https://assetstore.unity.com/packages/vfx/shaders/fullscreen-camera-effects/glitches-distortions-282947" demo="https://fronkongames.github.io/demos-glitches/distortions/" warn="assets used in video and demo are not included">}}

**Distortions** includes a variety of tools to warp, twist, and distort your game's visuals. Included effects: Fisheye, Gravity, Inflate, Magnifying, Raining, Scope, Swirl, Tremors, Underwater and Water 2D.

### üï≥Ô∏è Gravity {#gravity}

{{< video src="/store/glitches/distortions/gravity.mp4" loop="true" autoplay="true">}}

Black hole or warp effect.

{{< image src="gravity.jpg" wrapper="col-10 mx-auto">}}

Adjust the '**Center**' and '**Radius**' to define the affected area, and '**Strength**' for the gravitational pull.

It features advanced color controls for both the **Corona** (outer) and **Core** (inner) zones, including independent **Tint** and **Blend** operations.

### üíß Water 2D {#water2D}

{{< video src="/store/glitches/distortions/water2D.mp4" loop="true" autoplay="true">}}

Reflection and wave effect optimized for 2D planes.

{{< image src="water2D.jpg" wrapper="col-10 mx-auto">}}

Set the water '**Height**' (surface level), and adjust the wave '**Strength**', '**Frequency**', and reflection '**Angle**'.

Use '**Tint**' and '**Blend**' to define the water's appearance.

### üåä Under Water {#under-water}

{{< video src="/store/glitches/distortions/underwater.mp4" loop="true" autoplay="true">}}

Simulates being submerged.

{{< image src="underwater.jpg" wrapper="col-10 mx-auto">}}

Adjust the wave '**Strength**', '**Speed**', and '**Amplitude**'.

It includes a powerful depth-based coloring system: activate '**Use Depth**' to apply different '**Tint**' values for near (**Depth 0**) and far (**Depth 1**) objects, modulated by '**Depth Power**'.

{{< alert color="success" icon="fas circle-info" >}}
In order to use this feature, you must enable '**Depth Texture**' in your camera or pipeline settings.
{{< /alert >}}

### üåßÔ∏è Raining {#raining}

{{< video src="/store/glitches/distortions/raining.mp4" loop="true" autoplay="true">}}

Simulates vision through a rain-streaked window.

{{< image src="raining.jpg" wrapper="col-10 mx-auto">}}

Control the overall '**Strength**', the '**Speed**' of the falling drops [-1.0 - 1.0], and their '**Density**'.

Use '**Tint**' and '**Blend**' to adjust the visual integration.

### üîç Magnifying {#magnifying}

{{< video src="/store/glitches/distortions/magnifying.mp4" loop="true" autoplay="true">}}

Simulates a magnifying lens.

{{< image src="magnifying.jpg" wrapper="col-10 mx-auto">}}

Adjust the '**Center**', '**Magnification**' (zoom level), and '**Radius**' of the lens.

{{< alert color="info" icon="fas triangle-exclamation" >}}
High values of '**Magnification**' can show very pixelated images.
{{< /alert >}}

You can customize the look with '**Tint**' and '**Border**' settings.

It also includes '**Distortion**' and '**Distortion Power**' to simulate chromatic aberration at the lens edges.

### üå™Ô∏è Swirl {#swirl}

{{< video src="/store/glitches/distortions/swirl.mp4" loop="true" autoplay="true">}}

Twists the screen around a point.

{{< image src="swirl.jpg" wrapper="col-10 mx-auto">}}

Adjust the '**Angle**' of torsion [-1080.0, 1080.0], the reach with '**Radius**', and the anchor point with '**Center**'.

'**Threshold**' controls the smoothness of the effect transition at the edges.

### ü´® Tremors {#tremors}

{{< video src="/store/glitches/distortions/tremors.mp4" loop="true" autoplay="true">}}

Screen shake and blur effect.

{{< image src="tremors.jpg" wrapper="col-10 mx-auto">}}

Increase '**Samples**' for higher blur quality [1 - 5].

You can control '**Strength**' and '**Speed**' independently for each axis, and adjust the wave '**Amplitude**' and '**Frequency**' for complex vibrations.

### üéØ Scope {#scope}

{{< video src="/store/glitches/distortions/scope.mp4" loop="true" autoplay="true">}}

Sniper scope or barrel distortion.

{{< image src="scope.jpg" wrapper="col-10 mx-auto">}}

Features '**Center**' and '**Radius**' for aiming, a '**Vignette**' for edge darkening, and '**Radial Distortion**' based on a lens [formula](https://docs.opencv.org/4.x/d9/d0c/group__calib3d.html#:%7E:text=The%20next%20figures,monotonically%20increasing) (K1, K2, K3).

'**Dispersion**' adds chromatic aberration at the edges of the sight.

### üéà Inflate {#inflate}

{{< video src="/store/glitches/distortions/inflate.mp4" loop="true" autoplay="true">}}

Swell or deflate specific areas.

{{< image src="inflate.jpg" wrapper="col-10 mx-auto">}}

Use a positive '**Strength**' to inflate and negative to deflate [-1.0, 1.0].

The '**Radius**' and '**Center**' define the focus and reach of the deformation.

### üêü Fisheye {#fisheye}

{{< video src="/store/glitches/distortions/fisheye.mp4" loop="true" autoplay="true">}}

Classic lens distortion.

{{< image src="fisheye.jpg" wrapper="col-10 mx-auto">}}

Use '**Strength**' to adjust the intensity: values above 0 for a fisheye effect, and below 0 for anti-fisheye [-0.5, 0.5].

You can also set the '**Center**' of the distortion, and use '**Blend**' and '**Tint**' to modify the final color.

---
## üì∑ Cheap Camera {#cheap-camera}

{{< asset-header youtube="GJZYzdBmruM" store="https://assetstore.unity.com/packages/vfx/shaders/fullscreen-camera-effects/glitches-cheap-camera-287563" demo="https://fronkongames.github.io/demos-glitches/cheap-camera/" warn="assets used in video and demo are not included">}}

**Cheap Camera** replicates the visual characteristics of low-quality cameras, including lens distortion, sensor noise, and poor color reproduction.

Once installed, when you select your '_Volume_', you will see something like this:

{{< image src="cheap_camera_0.jpg" wrapper="col-10 mx-auto">}}

With '**Intensity**' you can control the overall strength of the effect [0.0 - 1.0]. If it is 0, the effect will not be active.

These parameters simulate the imperfections of cheap optics. You can adjust the '**Vignette**' to darken or brighten the corners, and use '**Chromatic Aberration**' to add color fringing at the edges.

The physical deformation of the image is controlled through '**Radial Distortion**' (curvature) and '**Tangential Distortion**' (misalignment), while '**Zoom**' allows for field of view adjustments.

#### Sensor Settings
These settings replicate the limitations of low-end image sensors. Use '**Resolution**' to simulate low pixel counts, and adjust '**Blur Quality**' for the desired aesthetic.

You can add static or dynamic grain with '**Pixel Noise**', and control the signal strength before and after noise application using '**Exposure**' and '**Gain**'.

Finally, '**Dynamic Range**' modulates the sensor's bit depth for color reproduction.

#### Processor Settings

Simulates internal camera image processing. This section includes '**Functions**' for edge detection, sharpening, and pixel size adjustments.

You can also fine-tune the '**White Balance**' to shift the overall color temperature of the captured frame.

---
## üî• Bap GPU {#bad-gpu}
{{< asset-header youtube="Q86NARQPUJk" store="https://assetstore.unity.com/packages/vfx/shaders/fullscreen-camera-effects/glitches-bad-gpu-288689" demo="https://fronkongames.github.io/demos-glitches/bad-gpu/" warn="assets used in video and demo are not included">}}

Simulates the visual artifacts characteristic of failing graphics hardware, including pixel scrambling, memory corruption patterns, and signal degradation. Unlike other glitch effects that simulate external interference, this effect emulates internal GPU malfunction through sophisticated coordinate manipulation and noise generation algorithms.

The core innovation lies in the use of **Morton/Z-order** curves for pixel coordinate transformation. This space-filling curve algorithm interleaves bits from X and Y coordinates to create a linear index that preserves spatial locality. When noise is applied to this Morton-encoded index and then converted back to UV coordinates, the result creates the characteristic blocky, hardware-corruption appearance rather than smooth gradient distortions.

{{< alert type="info" >}}
The Morton curve implementation uses O(1) bit manipulation tricks, enabling real-time pixel scrambling without expensive texture lookups or compute shaders.
{{< /alert >}}

#### Requisites

To ensure optimal performance and compatibility, your project must meet the following requirements:

*   **Unity:** 6000.0.58f1 or higher.
*   **Universal RP:** 17.0.3 or higher.

#### Instalation Guide

##### Step 1: Add Renderer Feature

The effect must be registered in your project's URP configuration:

1. Locate your **Universal Renderer Data** asset.
2. Click **Add Renderer Feature** and select **Fronkon Games > Glitches > Bad GPU**.

##### Step 2: Configure the Volume

To apply the effect to your scene:

1. Create a **Volume** component (Global or Local).
2. In the Volume component, create or assign a **Volume Profile**.
3. Click **Add Override** and select **Fronkon Games > Glitches > Bad GPU**.
4. Enable the '**Intensity**' parameter (and any others you wish to modify).

#### Parameter Configuration

{{< image src="badgpu_0.jpg" wrapper="col-10 mx-auto">}}

With '**Intensity**' you can control the overall strength of the effect [0.0 - 1.0]. If it is 0, the effect will not be active.

##### Signal Parameters

The core parameters control the balance between the original image and the corrupted output.

* **Balance** [-1.0 to 1.0]: Negative values favor the original image, positive values enhance the glitch effect. At 0.0, mixing depends on pixel difference magnitude.
* **Booster** [0.0 to 10.0]: Multiplies the glitch color intensity before blending. Higher values create more severe corruption.
* **Blend**: Selects from 23 color blend modes (Solid, Screen, Difference, etc.).
* **Tint**: Applies a color filter to the glitch artifacts before blending.

##### Four-Layer Glitch System

The effect implements four independent noise layers (Glitch 1-4), each contributing distinct artifact patterns. This multi-layered approach simulates the complex cascading failures that occur in actual GPU hardware problems.

{{< table >}}
| **Layer** | **Noise Scale** | **Characteristic** | **Typical Use Case** |
|---|---|---|---|
| Glitch 1 | 1√ó10‚Åª¬≥ | Blocky posterized artifacts with 4 levels | Main chunk corruption |
| Glitch 2 | 1√ó10‚Åª‚Åµ | Fine-grained noise with 20 posterization levels | Bit-level errors |
| Glitch 3 | 1√ó10¬≥ | Large-scale displacement with threshold control | Memory addressing failures |
| Glitch 4 | 0.01 | Subtle random color injection | Signal degradation |
{{< /table >}}

Each layer combines three operations: noise generation scaled by coordinate position, posterization for quantization, and threshold application for selective activation. The noise function uses 1D value noise with linear interpolation, scaled by time-dependent speed parameters.

##### Color Grading

Standard color correction parameters apply to the final output.

{{< table >}}
| **Parameter** | **Range** | **Effect** | **Default** |
|---|---|---|---|
| Brightness | -1.0 to 1.0 | Additive luminance offset | 0.0 |
| Contrast | 0.0 to 10.0 | Mid-tone contrast expansion | 1.0 |
| Gamma | 0.1 to 10.0 | Nonlinear tonal mapping (inverted) | 1.0 |
| Hue | 0.0 to 1.0 | Color wheel rotation | 0.0 |
| Saturation | 0.0 to 2.0 | Color intensity relative to luminance | 1.0
{{< /table >}}

These operations follow standard image processing order: contrast expansion ‚Üí hue rotation ‚Üí gamma correction ‚Üí saturation adjustment.

#### Runtime Control

The effect integrates with Unity's Volume system for seamless runtime parameter modification. Access the **BadGPUVolume** component through the Volume Profile.

```csharp
using UnityEngine;
using UnityEngine.Rendering;
using FronkonGames.Glitches.BadGPU;

// ...

[SerializedField]
private VolumeProfile volumeProfile;

// ...

// Access the effect
if (volumeProfile.TryGet(out BadGPUVolume volume))
{
    // Enable/disable effect
    volume.intensity.value = 1.0f; // 0.0 = disabled
    
    // Configure signal parameters
    volume.balance.value = 0.3f;
    volume.booster.value = 2.5f;
    volume.blend.value = ColorBlends.Difference;
    volume.tint.value = new Color(1.0f, 0.5f, 0.0f);
    
    // Control individual glitch layers
    volume.glitch1.value = 0.2f;
    volume.glitch1Speed.value = 0.5f;
    volume.glitch1Threshold.value = 0.6f;
    
    // Apply color correction
    volume.contrast.value = 1.2f;
    volume.saturation.value = 0.8f;
}
```

For a more detailed example, check the code in the demo scene.

##### Performance Characteristics

The effect executes in a single render pass with **O(1)** per-pixel complexity. The Morton curve operations use bitwise manipulation without branching, and noise generation employs analytical functions rather than texture lookups.

Performance considerations:

* Pass Count: 1 blit pass.
* Texture Samples: 2 per pixel (original and displaced coordinate).
* Branching: Minimal (threshold comparisons use step() intrinsic).
* Memory: No additional textures or compute buffers.

#### Preset Configurations

##### Subtle Artifacts

Suitable for environmental storytelling or failing electronics.

```
Intensity: 0.15, Balance: -0.3, Booster: 0.8, Blend: Solid
Glitch 1: Intensity 0.05, Speed 0.2, Threshold 0.8
Glitch 2: Intensity 0.03, Speed 2.0, Threshold 0.95
```

##### Critical Failure

Creates severe corruption for intense scenes or catastrophic events.

```
Intensity: 0.8, Balance: 0.4, Booster: 5.0, Blend: Difference, Tint: Orange
Glitch 1: Intensity 0.3, Speed 1.0, Threshold 0.6
Glitch 2: Intensity 0.2, Speed 4.0, Threshold 0.8
Glitch 3: Intensity 0.2, Speed 0.5, Threshold 0.5
Glitch 4: Intensity 0.15, Speed 0.1, Threshold 0.9
```

---
## üì¶ Artifacts {#artifacts}
{{< asset-header youtube="tyg11e6XrQQ" store="https://assetstore.unity.com/packages/vfx/shaders/fullscreen-camera-effects/glitches-artifacts-288952" demo="https://fronkongames.github.io/demos-glitches/artifacts/" warn="assets used in video and demo are not included">}}

Replicates the visual noise and blocking patterns characteristic of low-bitrate digital video, poor signal reception, or heavily compressed media. The effect simulates macro-block corruption, horizontal line tearing, chromatic aberration, and RGB sub-pixel interleaving, the hallmarks of degraded digital video signals.

The core technique uses a **noise texture lookup** driven by time-varying block coordinates. Screen pixels are quantized into configurable grid cells, and the resulting cell index is used to sample a noise texture at animated UV offsets. When the noise value crosses a probability threshold, the pixel undergoes color channel displacement, blend-mode tinting, and sub-pixel masking, all in a single shader pass.

{{< alert type="info" >}}
Luminance-range filtering allows the effect to target only specific brightness levels, enabling selective corruption of shadows or highlights without affecting the rest of the image.
{{< /alert >}}

#### Requisites

To ensure optimal performance and compatibility, your project must meet the following requirements:

*   **Unity:** 6000.0.58f1 or higher.
*   **Universal RP:** 17.0.3 or higher.

#### Instalation Guide

##### Step 1: Add Renderer Feature

The effect must be registered in your project's URP configuration:

1. Locate your **Universal Renderer Data** asset.
2. Click **Add Renderer Feature** and select **Fronkon Games > Glitches > Artifacts**.

##### Step 2: Configure the Volume

To apply the effect to your scene:

1. Create a **Volume** component (Global or Local).
2. In the Volume component, create or assign a **Volume Profile**.
3. Click **Add Override** and select **Fronkon Games > Glitches > Artifacts**.
4. Enable the '**Intensity**' parameter (and any others you wish to modify).

#### Dual-Layer Artifact

The effect implements two independent artifact layers ‚Äî **Blocks** and **Lines** ‚Äî each with its own probability, blend mode, and tint color. This dual-layer approach simulates the distinct corruption patterns found in real degraded video signals.

{{< table >}}
| **Layer** | **Pattern** | **Characteristic** | **Typical Use Case** |
|---|---|---|---|
| Blocks | Grid-aligned macro-blocks | Random rectangular corruption patches | Compression artifacts, data loss |
| Lines | Horizontal scan-lines | Full-width horizontal tearing | Signal interference, bad reception |
{{< /table >}}

Both layers share the same noise texture and block-size grid, but sample different noise channels (red for blocks, green/blue for lines). Time-dependent power curves control the probability of each layer activating per frame, creating organic temporal variation.

#### Parameter Configuration

{{< image src="artifacts_0.jpg" wrapper="col-10 mx-auto">}}

With '**Intensity**' you can control the overall strength of the effect [0.0 - 1.0]. If it is 0, the effect will not be active.

* **Size** [Vector2Int]: Defines the dimensions of the artifact grid cells in pixels. Default (16, 16). Smaller values produce finer corruption; larger values create chunkier macro-blocks.
* **Luminance Range** [Vector2]: Restricts the effect to pixels within a specific brightness range. Pixels with luminance outside [min, max] are left untouched. Default (0.0, 1.0).
* **Blocks** [0.0 to 1.0]: Controls the probability and intensity of macro-block artifacts. Default 0.1.
* **Block Blend**: Selects from 23 color blend modes (Multiply, Screen, Difference, etc.). Default Multiply.
* **Block Tint**: Color and alpha applied to block artifacts. Alpha controls the blend strength. Default (0, 1, 0, 0.25).
* **Lines** [0.0 to 1.0]: Controls the probability and intensity of horizontal line artifacts. Default 0.4.
* **Line Blend**: Selects from 23 color blend modes. Default Multiply.
* **Line Tint**: Color and alpha applied to line artifacts. Alpha controls the blend strength. Default (0, 1, 0, 0.5).
* **Aberration** [0.0 to 1.0]: Chromatic aberration intensity. Displaces R, G, and B channels independently when artifacts are active. Default 0.3.
* **Interleave** [0.0 to 1.0]: RGB sub-pixel pattern intensity. Simulates CRT-style sub-pixel rendering within corrupted regions. Default 1.0.

##### Color Grading

Standard color correction parameters apply to the final output.

{{< table >}}
| **Parameter** | **Range** | **Effect** | **Default** |
|---|---|---|---|
| Brightness | -1.0 to 1.0 | Additive luminance offset | 0.0 |
| Contrast | 0.0 to 10.0 | Mid-tone contrast expansion | 1.0 |
| Gamma | 0.1 to 10.0 | Nonlinear tonal mapping (inverted) | 1.0 |
| Hue | 0.0 to 1.0 | Color wheel rotation | 0.0 |
| Saturation | 0.0 to 2.0 | Color intensity relative to luminance | 1.0
{{< /table >}}

These operations follow standard image processing order: contrast expansion ‚Üí hue rotation ‚Üí gamma correction ‚Üí saturation adjustment.

#### Runtime Control

The effect integrates with Unity's Volume system for seamless runtime parameter modification. Access the **ArtifactsVolume** component through the Volume Profile.

```csharp
using UnityEngine;
using UnityEngine.Rendering;
using FronkonGames.Glitches.Artifacts;

// ...

[SerializedField]
private VolumeProfile volumeProfile;

// ...

// Access the effect
if (volumeProfile.TryGet(out ArtifactsVolume volume))
{
    // Enable/disable effect
    volume.intensity.value = 1.0f; // 0.0 = disabled

    // Configure artifact parameters
    volume.size.value = new Vector2Int(8, 8);
    volume.luminanceRange.value = new Vector2(0.0f, 1.0f);
    volume.blocks.value = 0.8f;
    volume.blockBlend.value = ColorBlends.Difference;
    volume.blockTint.value = new Color(0.0f, 1.0f, 0.0f, 0.25f);
    volume.lines.value = 0.4f;
    volume.lineBlend.value = ColorBlends.Multiply;
    volume.lineTint.value = new Color(0.0f, 1.0f, 0.0f, 0.5f);
    volume.aberration.value = 0.3f;
    volume.interleave.value = 1.0f;

    // Apply color correction
    volume.contrast.value = 1.2f;
    volume.saturation.value = 0.8f;
}
```

For a more detailed example, check the code in the demo scene.

#### Performance Characteristics

The effect executes in a single render pass with **O(1)** per-pixel complexity. Block coordinates are computed via integer division, and noise sampling uses a pre-baked 64√ó64 texture with linear filtering.

Performance considerations:

* Pass Count: 1 blit pass.
* Texture Samples: 4 per pixel (original + up to 3 displaced channels) + noise lookups.
* Branching: Conditional blocks use UNITY_BRANCH for coherent warp execution.
* Memory: 1 additional noise texture (64√ó64).

#### Preset Configurations

##### Subtle Compression

Suitable for surveillance cameras, old monitors, or low-quality video feeds.

```
Intensity: 0.3, Size: (16, 16), Luminance Range: (0.0, 1.0)
Blocks: 0.05, Block Blend: Multiply, Block Tint: (0, 1, 0, 0.15)
Lines: 0.2, Line Blend: Multiply, Line Tint: (0, 1, 0, 0.3)
Aberration: 0.1, Interleave: 0.5
```

##### Heavy Signal Loss

Creates severe corruption for dramatic transitions or horror sequences.

```
Intensity: 0.8, Size: (8, 8), Luminance Range: (0.0, 1.0)
Blocks: 0.6, Block Blend: Difference, Block Tint: (0, 1, 0, 0.5)
Lines: 0.8, Line Blend: Screen, Line Tint: (1, 0, 0, 0.6)
Aberration: 0.8, Interleave: 1.0
```

---
## üíÄ Hacked {#hacked}
{{< asset-header youtube="gjgyrVs8yx0" store="https://assetstore.unity.com/packages/vfx/shaders/fullscreen-camera-effects/glitches-hacked-293724" demo="https://fronkongames.github.io/demos-glitches/hacked/" warn="assets used in video and demo are not included">}}

**Hacked** is a high-performance post-processing effect that simulates a variety of digital glitches, frame jumps, and compression artifacts, giving the impression of a hacked or malfunctioning system.

Once installed, when you select your '_Volume_', you will see something like this:

{{< image src="hacked_0.jpg" wrapper="col-10 mx-auto">}}

With '**Intensity**' you can control the overall strength of the effect [0.0 - 1.0]. If it is 0, the effect will not be active.

The hacking effect is achieved by combining six different effects. '**Strength**' modulates the intensity of **all** these effects.

{{< video src="/store/glitches/hacked/hacked_framejump.mp4" loop="true" autoplay="true" title="Frame jump" >}}

The first effect is '**Frame jump**', commonly caused by a synchronization failure between the signal and the monitor. In addition to its intensity, you can adjust its speed.

{{< video src="/store/glitches/hacked/hacked_jitter.mp4" loop="true" autoplay="true" title="Jitter" >}}

'**Jitter**' creates horizontal bands that _slice_ the image. In addition to their intensity and speed, you can modify their density.

{{< video src="/store/glitches/hacked/hacked_blocks.mp4" loop="true" autoplay="true" title="Blocks" >}}

'**Blocks**' creates a multitude of blocks that deform the color channels. You can adjust their density, chromatic aberration intensity and noise.

{{< video src="/store/glitches/hacked/hacked_waves.mp4" loop="true" autoplay="true" title="Waves" >}}

With '**Waves**' you can add a sine wave deformation that alters the color channels, and you can adjust its speed and the intensity of the color channel separation.

{{< video src="/store/glitches/hacked/hacked_scanlines.mp4" loop="true" autoplay="true" title="Scanlines" >}}

'**Scanlines**' adds a horizontal noise.

{{< video src="/store/glitches/hacked/hacked_noise.mp4" loop="true" autoplay="true" title="Noise" >}}

Finally '**Noise**' creates the classic analog noise.

---
## üî® Broken LCD {#broken-lcd}
{{< asset-header youtube="BgRcZrxu280" store="https://assetstore.unity.com/packages/vfx/shaders/fullscreen-camera-effects/glitches-broken-lcd-294991" demo="https://fronkongames.github.io/demos-glitches/broken-lcd/" warn="assets used in video and demo are not included">}}

Simulates the visual artifacts of a physically damaged liquid crystal display, including dead pixel clusters, color bleeding, and screen fractures. The effect produces the distinctive blocky, high-contrast patterns seen when an LCD panel's internal structure is compromised, cracked substrates, severed column drivers, or pressure-damaged cells.

The core algorithm uses an **iterative hash-based cell fracture** system. Screen coordinates are divided into a configurable grid, and each cell is processed through multiple complexity iterations using a 4-component hash function (`Hash42`). At each iteration, UV coordinates are warped by the hash output, accumulating multiplicative color corruption. A final threshold test separates "broken" regions from intact areas, with blend-mode compositing applied only to damaged zones.

{{< alert type="info" >}}
The iterative fracture loop produces self-similar patterns at different scales, increasing Complexity adds finer sub-fractures within existing damaged regions, mimicking real LCD crack propagation.
{{< /alert >}}

#### Requisites

To ensure optimal performance and compatibility, your project must meet the following requirements:

*   **Unity:** 6000.0.58f1 or higher.
*   **Universal RP:** 17.0.3 or higher.

#### Instalation Guide

##### Step 1: Add Renderer Feature

The effect must be registered in your project's URP configuration:

1. Locate your **Universal Renderer Data** asset.
2. Click **Add Renderer Feature** and select **Fronkon Games > Glitches > Broken LCD**.

##### Step 2: Configure the Volume

To apply the effect to your scene:

1. Create a **Volume** component (Global or Local).
2. In the Volume component, create or assign a **Volume Profile**.
3. Click **Add Override** and select **Fronkon Games > Glitches > Broken LCD**.
4. Enable the '**Intensity**' parameter (and any others you wish to modify).

#### Facture Generation Pipeline

The effect processes each pixel through a multi-stage pipeline that separates the screen into damaged and intact regions, then composites them independently.

{{< table >}}
| **Stage** | **Operation** | **Controlled By** |
|---|---|---|
| Grid Division | Screen split into cells with aspect-ratio correction | Cells |
| UV Animation | Cell coordinates offset by time-driven hash | Speed |
| Iterative Fracture | N iterations of hash-based UV warping and color accumulation | Complexity, Density |
| Tilt Distortion | Horizontal shear applied to vertical coordinates | Tilt |
| Threshold Split | Broken vs. intact region classification via luminance length | Threshold |
| Compositing | Blend-mode mixing with offset sampling for broken areas | Blend, Offset, Broken Tint, Background Tint |
{{< /table >}}

The iterative loop at the core alternates warp direction each iteration (`s = -s * (1.1 + h.y)`), producing organic zigzag fracture patterns rather than uniform grid distortion.

#### Parameter Configuration

{{< image src="brokenlcd_0.jpg" wrapper="col-10 mx-auto">}}

With '**Intensity**' you can control the overall strength of the effect [0.0 - 1.0]. If it is 0, the effect will not be active.

The core parameters control the generation and appearance of LCD damage artifacts.

* **Complexity** [1 to 10]: Number of fracture iterations per pixel. Higher values produce finer, more detailed crack patterns at the cost of additional hash computations. Default 6.
* **Density** [0.0 to 1.0]: Controls the probability of color corruption at each iteration. Lower values leave more cells intact; higher values produce denser damage. Default 0.5.
* **Cells** [Vector2Int]: Number of grid divisions on each axis. The X component controls horizontal segmentation, Y controls vertical. Default (1, 8).
* **Speed** [0.0 to 5.0]: Frame rate of pattern change. Controls how quickly the fracture pattern animates over time. Default 0.3.
* **Offset** [0.0 to 1.0]: UV displacement applied when sampling the original image in broken regions. Creates the characteristic "shifted content" look of damaged displays. Default 0.1.
* **Tilt** [0.0 to 1.0]: Horizontal shear applied to the fracture pattern. Simulates angled crack lines across the display. Default 0.2.
* **Threshold** [0.0 to 1.0]: Activation limit that separates broken from intact regions. Lower values expand the damaged area; higher values restrict it. Default 0.75.
* **Blend**: Selects from 23 color blend modes (HardMix, Screen, Difference, etc.) for compositing broken regions. Default HardMix.
* **Broken Tint**: Color multiplier applied to damaged areas. Default White.
* **Background Tint**: Color multiplier applied to intact areas. Default White.

##### Color Grading

Standard color correction parameters apply to the final output.

{{< table >}}
| **Parameter** | **Range** | **Effect** | **Default** |
|---|---|---|---|
| Brightness | -1.0 to 1.0 | Additive luminance offset | 0.0 |
| Contrast | 0.0 to 10.0 | Mid-tone contrast expansion | 1.0 |
| Gamma | 0.1 to 10.0 | Nonlinear tonal mapping (inverted) | 1.0 |
| Hue | 0.0 to 1.0 | Color wheel rotation | 0.0 |
| Saturation | 0.0 to 2.0 | Color intensity relative to luminance | 1.0
{{< /table >}}

These operations follow standard image processing order: contrast expansion ‚Üí hue rotation ‚Üí gamma correction ‚Üí saturation adjustment.

##### Runtime Control

The effect integrates with Unity's Volume system for seamless runtime parameter modification. Access the **BrokenLCDVolume** component through the Volume Profile.

```csharp
using UnityEngine;
using UnityEngine.Rendering;
using FronkonGames.Glitches.BrokenLCD;

// ...

[SerializedField]
private VolumeProfile volumeProfile;

// ...

// Access the effect
if (volumeProfile.TryGet(out BrokenLCDVolume volume))
{
    // Enable/disable effect
    volume.intensity.value = 1.0f; // 0.0 = disabled

    // Configure fracture parameters
    volume.complexity.value = 8;
    volume.density.value = 0.6f;
    volume.cells.value = new Vector2Int(2, 10);
    volume.speed.value = 0.5f;
    volume.offset.value = 0.15f;
    volume.tilt.value = 0.3f;
    volume.threshold.value = 0.7f;
    volume.blend.value = ColorBlends.HardMix;
    volume.brokenTint.value = Color.white;
    volume.backgroundTint.value = new Color(0.9f, 0.9f, 1.0f);

    // Apply color correction
    volume.contrast.value = 1.2f;
    volume.saturation.value = 0.8f;
}
```

For a more detailed example, check the code in the demo scene.

#### Performance Characteristics

The effect executes in a single render pass. Per-pixel cost scales linearly with the **Complexity** parameter, as each iteration performs one `Hash42` evaluation and UV warp.

Performance considerations:

* Pass Count: 1 blit pass.
* Texture Samples: 2 per pixel (original + offset-displaced sample in broken regions).
* Branching: Threshold split and density check use UNITY_BRANCH for coherent warp execution.
* Memory: No additional textures or compute buffers.
* Loop Cost: O(Complexity) hash evaluations per pixel (default 6).

#### Preset Configurations

##### Subtle Compression

Suitable for aged electronics, slightly cracked screens, or environmental storytelling.

```
Intensity: 0.3, Complexity: 4, Density: 0.3, Cells: (1, 6)
Speed: 0.1, Offset: 0.05, Tilt: 0.1, Threshold: 0.85
Blend: HardMix, Broken Tint: White, Background Tint: White
```
---

##### Shattered Display

Creates severe LCD destruction for dramatic impact or horror sequences.

```
Intensity: 0.9, Complexity: 10, Density: 0.8, Cells: (3, 12)
Speed: 0.5, Offset: 0.25, Tilt: 0.4, Threshold: 0.5
Blend: Difference, Broken Tint: (1, 0.8, 0.8), Background Tint: (0.7, 0.7, 0.9)
```

---
## üëÅÔ∏è‚Äçüó®Ô∏è Color Blindness {#colorblindness}
{{< asset-header youtube="f5CiPt9bzBE" store="https://assetstore.unity.com/packages/vfx/shaders/fullscreen-camera-effects/glitches-color-blindness-273126" demo="https://fronkongames.github.io/demos-glitches/colorblindness/" warn="assets used in video and demo are not included">}}

**Color Blindness** accurately replicates how people with different types of color vision deficiency perceive the world, making it an essential tool for accessibility testing and artistic expression.

{{< alert color="danger" icon="fas triangle-exclamation" >}}
This asset **simulates** a series of vision defects, **NOT** corrects them.
{{< /alert >}}

Once installed, when you select your '_Volume_', you will see something like this:

{{< image src="color_blindness_0.jpg" wrapper="col-10 mx-auto">}}

With '**Intensity**' you can control the overall strength of the effect [0.0 - 1.0]. If it is 0, the effect will not be active.

The core of the simulation is the '**Deficiency**' parameter, which allows you to select from a wide range of color vision conditions, including red-green (Protanopia, Deuteranopia), blue-yellow (Tritanopia), and total color blindness (Achromatopsia), as well as their anomalous trichromacy variants.

* **Protanomaly**: red-green vision deficiency, 1% of males, 0.03% of females.
* **Deuteranomaly**: red-green color blindness, 6% of males, 0.4% of females.
* **Tritanomaly**: blue-yellow color blindness, 0.01% for males and females.
* **Protanopia**: reds are greatly reduced, 1% of males, 0.02% of females.
* **Deuteranopia**: greens are greatly reduced, 1% of males.
* **Tritanopia**: blues are greatly reduced, 0.003% population.
* **Achromatopsia**: total color blindness, 0.001% population.
* **Achromatomaly**: partial color blindness, 0.00001% population.

To facilitate testing and visualization, you can use the '**Comparator**' to split the screen, allowing a direct side-by-side comparison between normal vision and the selected deficiency.

You can further customize this view by adjusting the '**Comparator Size**' and the '**Comparator Color**' of the dividing bar.

#
---

## Misc

All effects have a image grading tools, '**Color**', for aesthetic fine-tuning: **Brightness**, **Contrast**, **Gamma**, **Hue**, and **Saturation**.

{{< image src="color.jpg" wrapper="col-8 mx-auto">}}

They also have an '**Advanced**' panel with these options:

{{< image src="advanced.jpg" wrapper="col-8 mx-auto">}}

Activate '**Affect the Scene View**' if you want the effect to be applied also in the '_Scene_' window of the Editor.

---
## F.A.Q.

##### _Effect Not appearing_

If the effect doesn't appear in your scene:

1. **Verify Renderer Feature**: Check that the renderer feature is added to your Universal Renderer Data asset.
2. **Check Volume Profile**: Ensure a Volume component exists in your scene with the effect override enabled.
3. **Confirm Intensity**: Verify that the Intensity parameter is set to a value greater than 0.0 and enabled.
4. **Camera Settings**: Check that your camera has Post Processing enabled in the Camera component.

##### _How to make the effect also affect the UI?_

In order for the UI not to be affected by the effect, you should set the 'Render Mode' of your canvas from 'Screen Space - Overlay' to 'Screen Space - Camera' and dragging your camera with to 'Render Camera'.

{{< image src="ui.jpg" wrapper="col-6 mx-auto">}}

Note that when you make this change, the coordinates of your UI will be in camera space, so you will have to change them.
<br>

##### _When Bloom is added, its intensity is too low or the effect stops working._

Bloom's URP Unity effect is not compatible with postprocessing effects based on [ScriptableRendererFeature](https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@12.1/manual/renderer-features/scriptable-renderer-features/inject-a-pass-using-a-scriptable-renderer-feature.html?q=ScriptableRendererFeature) (like this one).

You will have to add your own one based on ScriptableRendererFeature or you can use [this one at no cost](https://github.com/FronkonGames/ScriptableRenderBloom) ;)
<br>

##### _Can I use it in a material?_

Yes! Any effect can easily be used on a material. Just follow these steps:

* In the '**Project**' window, open the '**Create**' menu with the right mouse button and select '**Create > Render Texture**'.
* Create a new camera and in '**Output Texture**' select the Render Texture previously created. Remember to activate '**Post Processing**' and select in '**Renderer**' where you have the effect added.
* In the material you want to use, select in '**Base Map**' the Render Texture.
<br>

---
## Support

Do you have any problem or any suggestions? Send me an email to **fronkongames@gmail.com** and I'll be happy to help you.

Remember that if you want to inform me of an error, it would help me if you sent to me the [log file](https://docs.unity3d.com/Manual/LogFiles.html).

{{< rawhtml >}}
<br><center><h4>
{{< /rawhtml >}}

{{< alert color="warning" >}}
If you are happy with this asset, consider write a review in the store

‚ù§Ô∏è thanks! ‚ù§Ô∏è
{{< /alert >}}

{{< rawhtml >}}
</center></h4>
{{< /rawhtml >}}
